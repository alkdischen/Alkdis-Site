<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>用 Rust 做类型体操 (下篇) - Alkdis Chen</title><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">

	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="用 Rust 做类型体操 (下篇)">
<meta itemprop="description" content="TL;DR: 本人前两周刚写的 type-exercise-in-rust (GitHub) 中已经包含了一整套数据库执行器的类型设计，本文将详细介绍整个设计过程中的思考过程和解决方案。
Day 7: 用宏关联逻辑类型和实际类型 在数据库系统中，逻辑类型和实际存储的类型往往不会是一一对应的关系。举例，CHAR 和 VARCHAR 是两种不同的逻辑类型，但大多数数据库系统对于这两种类型都会用同一种内存表示。在前几天的类型体操中，我们实现的类型都是实际类型 (Physical Type)。在今天，我们将会把逻辑类型和实际类型关联起来，并批量生成表达式。
目标 之前我们实现了 cmp_ge 这个函数，可以将两个输入 cast 成一个指定类型后进行比较。如何生成所有支持类型的 cmp_ge 函数呢？正常来说，我们可能需要：
pub fn build_binary_expression( f: ExpressionFunc, i1: DataType, i2: DataType, ) -&gt; Box&lt;dyn Expression&gt; { use ExpressionFunc::*; use crate::expr::cmp::*; use crate::expr::string::*; match f { CmpLe =&gt; match (i1, i2) { (DataType::BigInt, DataType::Integer) =&gt; Box::new( BinaryExpression::&lt;i64, i32, bool, _&gt;::new(cmp_le::&lt;i64, i32, i64&gt;), ), (DataType::Integer, DataType::BigInt) =&gt; Box::new( BinaryExpression::&lt;i32, i64, bool, _&gt;::new(cmp_le::&lt;i32, i64, i64&gt;), ), _ =&gt; unimplemented!"><meta itemprop="datePublished" content="2022-02-01T14:00:00+08:00" />
<meta itemprop="dateModified" content="2022-02-01T14:00:00+08:00" />
<meta itemprop="wordCount" content="1202">
<meta itemprop="keywords" content="Rust,数据库,执行器,类型,GAT," /><meta property="og:title" content="用 Rust 做类型体操 (下篇)" />
<meta property="og:description" content="TL;DR: 本人前两周刚写的 type-exercise-in-rust (GitHub) 中已经包含了一整套数据库执行器的类型设计，本文将详细介绍整个设计过程中的思考过程和解决方案。
Day 7: 用宏关联逻辑类型和实际类型 在数据库系统中，逻辑类型和实际存储的类型往往不会是一一对应的关系。举例，CHAR 和 VARCHAR 是两种不同的逻辑类型，但大多数数据库系统对于这两种类型都会用同一种内存表示。在前几天的类型体操中，我们实现的类型都是实际类型 (Physical Type)。在今天，我们将会把逻辑类型和实际类型关联起来，并批量生成表达式。
目标 之前我们实现了 cmp_ge 这个函数，可以将两个输入 cast 成一个指定类型后进行比较。如何生成所有支持类型的 cmp_ge 函数呢？正常来说，我们可能需要：
pub fn build_binary_expression( f: ExpressionFunc, i1: DataType, i2: DataType, ) -&gt; Box&lt;dyn Expression&gt; { use ExpressionFunc::*; use crate::expr::cmp::*; use crate::expr::string::*; match f { CmpLe =&gt; match (i1, i2) { (DataType::BigInt, DataType::Integer) =&gt; Box::new( BinaryExpression::&lt;i64, i32, bool, _&gt;::new(cmp_le::&lt;i64, i32, i64&gt;), ), (DataType::Integer, DataType::BigInt) =&gt; Box::new( BinaryExpression::&lt;i32, i64, bool, _&gt;::new(cmp_le::&lt;i32, i64, i64&gt;), ), _ =&gt; unimplemented!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.alkdischen.cn/posts/articles/2022-02-01-rust-type-exercise-in-database-executors-final/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-01T14:00:00+08:00" />
<meta property="article:modified_time" content="2022-02-01T14:00:00+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="用 Rust 做类型体操 (下篇)"/>
<meta name="twitter:description" content="TL;DR: 本人前两周刚写的 type-exercise-in-rust (GitHub) 中已经包含了一整套数据库执行器的类型设计，本文将详细介绍整个设计过程中的思考过程和解决方案。
Day 7: 用宏关联逻辑类型和实际类型 在数据库系统中，逻辑类型和实际存储的类型往往不会是一一对应的关系。举例，CHAR 和 VARCHAR 是两种不同的逻辑类型，但大多数数据库系统对于这两种类型都会用同一种内存表示。在前几天的类型体操中，我们实现的类型都是实际类型 (Physical Type)。在今天，我们将会把逻辑类型和实际类型关联起来，并批量生成表达式。
目标 之前我们实现了 cmp_ge 这个函数，可以将两个输入 cast 成一个指定类型后进行比较。如何生成所有支持类型的 cmp_ge 函数呢？正常来说，我们可能需要：
pub fn build_binary_expression( f: ExpressionFunc, i1: DataType, i2: DataType, ) -&gt; Box&lt;dyn Expression&gt; { use ExpressionFunc::*; use crate::expr::cmp::*; use crate::expr::string::*; match f { CmpLe =&gt; match (i1, i2) { (DataType::BigInt, DataType::Integer) =&gt; Box::new( BinaryExpression::&lt;i64, i32, bool, _&gt;::new(cmp_le::&lt;i64, i32, i64&gt;), ), (DataType::Integer, DataType::BigInt) =&gt; Box::new( BinaryExpression::&lt;i32, i64, bool, _&gt;::new(cmp_le::&lt;i32, i64, i64&gt;), ), _ =&gt; unimplemented!"/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="https://www.alkdischen.cn/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://www.alkdischen.cn/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="https://www.alkdischen.cn/css/dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="https://www.alkdischen.cn/js/main.js"></script>
	
</head>



<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="https://www.alkdischen.cn/">
				<img src="https://picgo-1313480473.cos.ap-shanghai.myqcloud.com/Blog/sculpture.jpg" alt="Alkdis Chen" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="https://www.alkdischen.cn/">Alkdis Chen</a></h1>
	<div class="site-description"><p>Coding with wind</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/ikoltech" title="GitHub"><i data-feather="github"></i></a></li></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">推文</a>
			</li>
			
			<li>
				<a href="/posts-ng">Posts</a>
			</li>
			
			<li>
				<a href="/pages/about">About</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					
						<div class="meta">
							<div class="date">
								<span class="day">01</span>
								<span class="rest">Feb 2022</span>
							</div>
						</div>
					
				
				<div class="matter">
					<h1 class="title">用 Rust 做类型体操 (下篇)</h1>
					
				</div>
			</div>
					
			<div>
				
					<nav id="TableOfContents">
  <ul>
    <li><a href="#day-7-用宏关联逻辑类型和实际类型">Day 7: 用宏关联逻辑类型和实际类型</a>
      <ul>
        <li><a href="#目标">目标</a></li>
        <li><a href="#用-macro-关联逻辑类型和实际类型">用 macro 关联逻辑类型和实际类型</a></li>
        <li><a href="#展开所有比较函数">展开所有比较函数</a></li>
      </ul>
    </li>
  </ul>
</nav>
					<hr>
				
			</div>
			<div class="markdown">
				<p>TL;DR: 本人前两周刚写的 <a href="https://github.com/skyzh/type-exercise-in-rust">type-exercise-in-rust (GitHub)</a> 中已经包含了一整套数据库执行器的类型设计，本文将详细介绍整个设计过程中的思考过程和解决方案。</p>
<h2 id="day-7-用宏关联逻辑类型和实际类型">Day 7: 用宏关联逻辑类型和实际类型</h2>
<p>在数据库系统中，逻辑类型和实际存储的类型往往不会是一一对应的关系。举例，<code>CHAR</code> 和 <code>VARCHAR</code> 是两种不同的逻辑类型，但大多数数据库系统对于这两种类型都会用同一种内存表示。在前几天的类型体操中，我们实现的类型都是实际类型 (Physical Type)。在今天，我们将会把逻辑类型和实际类型关联起来，并批量生成表达式。</p>
<h3 id="目标">目标</h3>
<p>之前我们实现了 <code>cmp_ge</code> 这个函数，可以将两个输入 cast 成一个指定类型后进行比较。如何生成所有支持类型的 <code>cmp_ge</code> 函数呢？正常来说，我们可能需要：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#00f">pub</span> <span style="color:#00f">fn</span> build_binary_expression(
</span></span><span style="display:flex;"><span>    f: <span style="color:#2b91af">ExpressionFunc</span>,
</span></span><span style="display:flex;"><span>    i1: <span style="color:#2b91af">DataType</span>,
</span></span><span style="display:flex;"><span>    i2: <span style="color:#2b91af">DataType</span>,
</span></span><span style="display:flex;"><span>) -&gt; Box&lt;<span style="color:#00f">dyn</span> Expression&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">use</span> ExpressionFunc::*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">use</span> <span style="color:#00f">crate</span>::expr::cmp::*;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">use</span> <span style="color:#00f">crate</span>::expr::string::*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">match</span> f {
</span></span><span style="display:flex;"><span>        CmpLe =&gt; <span style="color:#00f">match</span> (i1, i2) {
</span></span><span style="display:flex;"><span>            (DataType::BigInt, DataType::Integer) =&gt; Box::new(
</span></span><span style="display:flex;"><span>                BinaryExpression::&lt;<span style="color:#2b91af">i64</span>, <span style="color:#2b91af">i32</span>, <span style="color:#2b91af">bool</span>, _&gt;::new(cmp_le::&lt;<span style="color:#2b91af">i64</span>, <span style="color:#2b91af">i32</span>, <span style="color:#2b91af">i64</span>&gt;),
</span></span><span style="display:flex;"><span>            ),
</span></span><span style="display:flex;"><span>            (DataType::Integer, DataType::BigInt) =&gt; Box::new(
</span></span><span style="display:flex;"><span>                BinaryExpression::&lt;<span style="color:#2b91af">i32</span>, <span style="color:#2b91af">i64</span>, <span style="color:#2b91af">bool</span>, _&gt;::new(cmp_le::&lt;<span style="color:#2b91af">i32</span>, <span style="color:#2b91af">i64</span>, <span style="color:#2b91af">i64</span>&gt;),
</span></span><span style="display:flex;"><span>            ),
</span></span><span style="display:flex;"><span>            _ =&gt; unimplemented!(),
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        _ =&gt; unimplemented!(),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如此枚举所有的可能。想想我们的系统里面，现在一共有 8 种类型，于是乎这里可能要写 8 * 8 = 64 个 arm。每个 arm 都要将逻辑类型 <code>DataType</code> 和实际类型 <code>i32</code> 匹配起来，并指定 cast 的目标，很容易写错。</p>
<p>大家可能立刻可以想到，能不能用 associated type 来表示这些类型之间的关系呢？显然不行。其一，<code>DataType</code> 是一个 enum，里面的每个 variant 没有自己的类型，不能直接关联。其二，像 <code>CHAR</code>, <code>Decimal</code> 这种逻辑类型，往往会带上一些附加信息。比如 <code>CHAR</code> 的长度、<code>Decimal</code> 的精度等等。这样一来，根本没有办法使用 generic 提供的工具来进行逻辑类型和实际类型之间的关联。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#a31515">/// Encapsules all supported (logical) data types in the system.
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span><span style="color:#00f">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">pub</span> <span style="color:#00f">enum</span> <span style="color:#2b91af">DataType</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">/// Corresponding to Int16 physical type
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>    SmallInt,
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">/// Corresponding to Int32 physical type
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>    Integer,
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">/// Corresponding to Int64 physical type
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>    BigInt,
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">/// Corresponding to String physical type
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>    Varchar,
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">/// Corresponding to String physical type
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>    Char { width: <span style="color:#2b91af">u16</span> },
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">/// Corresponding to Bool physical type
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>    Boolean,
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">/// Corresponding to Float32 physical type
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>    Real,
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">/// Corresponding to Float64 physical type
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>    Double,
</span></span><span style="display:flex;"><span>    <span style="color:#a31515">/// Corresponding to Decimal physical type
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>    Decimal { scale: <span style="color:#2b91af">u16</span>, precision: <span style="color:#2b91af">u16</span> },
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>而我们的目标，是将 <code>build_expression</code> 写成这种形式：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#a31515">/// Build expression with runtime information.
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span><span style="color:#00f">pub</span> <span style="color:#00f">fn</span> build_binary_expression(
</span></span><span style="display:flex;"><span>    f: <span style="color:#2b91af">ExpressionFunc</span>,
</span></span><span style="display:flex;"><span>    i1: <span style="color:#2b91af">DataType</span>,
</span></span><span style="display:flex;"><span>    i2: <span style="color:#2b91af">DataType</span>,
</span></span><span style="display:flex;"><span>) -&gt; Box&lt;<span style="color:#00f">dyn</span> Expression&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">use</span> ExpressionFunc::*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">use</span> <span style="color:#00f">crate</span>::expr::cmp::*;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">use</span> <span style="color:#00f">crate</span>::expr::string::*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">match</span> f {
</span></span><span style="display:flex;"><span>        CmpLe =&gt; for_all_cmp_combinations! { impl_cmp_expression_of, i1, i2, cmp_le },
</span></span><span style="display:flex;"><span>        CmpGe =&gt; for_all_cmp_combinations! { impl_cmp_expression_of, i1, i2, cmp_ge },
</span></span><span style="display:flex;"><span>        CmpEq =&gt; for_all_cmp_combinations! { impl_cmp_expression_of, i1, i2, cmp_eq },
</span></span><span style="display:flex;"><span>        CmpNe =&gt; for_all_cmp_combinations! { impl_cmp_expression_of, i1, i2, cmp_ne },
</span></span><span style="display:flex;"><span>        StrContains =&gt; Box::new(BinaryExpression::&lt;String, String, <span style="color:#2b91af">bool</span>, _&gt;::new(
</span></span><span style="display:flex;"><span>            str_contains,
</span></span><span style="display:flex;"><span>        )),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>怎么办捏？</p>
<h3 id="用-macro-关联逻辑类型和实际类型">用 macro 关联逻辑类型和实际类型</h3>
<p>在 Day 3 中我们已经讲过 Rust 声明宏的特殊性：它的展开顺序是由外到里的。在这种情况下，我们如何定义 <code>DataType</code> 到实际类型的映射呢？</p>
<p>一种办法就是用类似于下面这种回调的方式：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#a31515">/// Association information for `Boolean` logical type.
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>macro_rules! boolean {
</span></span><span style="display:flex;"><span>    (<span style="color:#00f">$macro</span>:<span style="color:#2b91af">ident</span>) =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">$macro</span>! {
</span></span><span style="display:flex;"><span>            DataType::Boolean,
</span></span><span style="display:flex;"><span>            BoolArray,
</span></span><span style="display:flex;"><span>            <span style="color:#2b91af">bool</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">pub</span>(<span style="color:#00f">crate</span>) <span style="color:#00f">use</span> boolean;
</span></span></code></pre></div><p><code>boolean</code> 这个 macro 包含了 <code>DataType::Boolean</code> 的所有信息——它的逻辑类型是 Boolean，对应的 Array 类型是 <code>BoolArray</code>，标量类型是 <code>bool</code>。</p>
<p>再看一个例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#a31515">/// Association information for `Char` logical type.
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>macro_rules! fwchar {
</span></span><span style="display:flex;"><span>    (<span style="color:#00f">$macro</span>:<span style="color:#2b91af">ident</span>) =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">$macro</span>! {
</span></span><span style="display:flex;"><span>            DataType::Char { .. },
</span></span><span style="display:flex;"><span>            StringArray,
</span></span><span style="display:flex;"><span>            String
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">pub</span>(<span style="color:#00f">crate</span>) <span style="color:#00f">use</span> fwchar;
</span></span></code></pre></div><p><code>fwchar</code> 这个逻辑类型对应的 match pattern 是 <code>DataType::Char { .. }</code>，它可以出现在 match arm 里面。对应的 Array 类型是 <code>StringArray</code>，标量类型是 <code>String</code>。</p>
<p>接下来，使用者如何把里面的内容提出来捏？我们定义三个宏，分别 extract 里面的每一个元素：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#a31515">/// Get the type match pattern out of the type macro. e.g., `DataTypeKind::Decimal { .. }`.
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>macro_rules! datatype_match_pattern {
</span></span><span style="display:flex;"><span>    (<span style="color:#00f">$match_pattern</span>:<span style="color:#2b91af">pat</span>, <span style="color:#00f">$array</span>:<span style="color:#2b91af">ty</span>, <span style="color:#00f">$scalar</span>:<span style="color:#2b91af">ty</span>) =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">$match_pattern</span>
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">pub</span>(<span style="color:#00f">crate</span>) <span style="color:#00f">use</span> datatype_match_pattern;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a31515">/// Get the array type out of the type macro. e.g., `Int32Array`.
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>macro_rules! datatype_array {
</span></span><span style="display:flex;"><span>    (<span style="color:#00f">$match_pattern</span>:<span style="color:#2b91af">pat</span>, <span style="color:#00f">$array</span>:<span style="color:#2b91af">ty</span>, <span style="color:#00f">$scalar</span>:<span style="color:#2b91af">ty</span>) =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">$array</span>
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">pub</span>(<span style="color:#00f">crate</span>) <span style="color:#00f">use</span> datatype_array;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a31515">/// Get the scalar type out of the type macro. e.g., `i32`.
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>macro_rules! datatype_scalar {
</span></span><span style="display:flex;"><span>    (<span style="color:#00f">$match_pattern</span>:<span style="color:#2b91af">pat</span>, <span style="color:#00f">$array</span>:<span style="color:#2b91af">ty</span>, <span style="color:#00f">$scalar</span>:<span style="color:#2b91af">ty</span>) =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">$scalar</span>
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">pub</span>(<span style="color:#00f">crate</span>) <span style="color:#00f">use</span> datatype_scalar;
</span></span></code></pre></div><p>这样一来，我们就可以用 <code>fwchar! { datatype_match_pattern };</code> 来得到定义在 <code>fwchar</code> 宏里面的 <code>DataType::Char { .. }</code> 了。</p>
<p>用 <code>trace_macro</code> 看一下结果：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#00f">fn</span> test_macro_expand() {
</span></span><span style="display:flex;"><span>    trace_macros!(<span style="color:#00f">true</span>);
</span></span><span style="display:flex;"><span>    fwchar! { datatype_match_pattern };
</span></span><span style="display:flex;"><span>    boolean! { datatype_array };
</span></span><span style="display:flex;"><span>    decimal! { datatype_scalar };
</span></span><span style="display:flex;"><span>    trace_macros!(<span style="color:#00f">false</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>note: trace_macro
</span></span><span style="display:flex;"><span>   --&gt; src/datatype/macros.rs:164:5
</span></span><span style="display:flex;"><span>    |
</span></span><span style="display:flex;"><span>164 |     boolean! <span style="">{</span> datatype_array <span style="">}</span>;
</span></span><span style="display:flex;"><span>    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span></span><span style="display:flex;"><span>    |
</span></span><span style="display:flex;"><span>    = note: expanding `boolean! <span style="">{</span> datatype_array <span style="">}</span>`
</span></span><span style="display:flex;"><span>    = note: <span style="color:#00f">to</span> `datatype_array! <span style="">{</span> DataType :: Boolean, BoolArray, <span style="color:#2b91af">bool</span> <span style="">}</span>`
</span></span><span style="display:flex;"><span>    = note: expanding `datatype_array! <span style="">{</span> DataType :: Boolean, BoolArray, <span style="color:#2b91af">bool</span> <span style="">}</span>`
</span></span><span style="display:flex;"><span>    = note: <span style="color:#00f">to</span> `BoolArray`
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>note: trace_macro
</span></span><span style="display:flex;"><span>   --&gt; src/datatype/macros.rs:163:5
</span></span><span style="display:flex;"><span>    |
</span></span><span style="display:flex;"><span>163 |     fwchar! <span style="">{</span> datatype_match_pattern <span style="">}</span>;
</span></span><span style="display:flex;"><span>    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span></span><span style="display:flex;"><span>    |
</span></span><span style="display:flex;"><span>    = note: expanding `fwchar! <span style="">{</span> datatype_match_pattern <span style="">}</span>`
</span></span><span style="display:flex;"><span>    = note: <span style="color:#00f">to</span> `datatype_match_pattern! <span style="">{</span> DataType :: <span style="color:#2b91af">Char</span> <span style="">{</span> .. <span style="">}</span>, StringArray, String <span style="">}</span>`
</span></span><span style="display:flex;"><span>    = note: expanding `datatype_match_pattern! <span style="">{</span> DataType :: <span style="color:#2b91af">Char</span> <span style="">{</span> .. <span style="">}</span>, StringArray, String <span style="">}</span>`
</span></span><span style="display:flex;"><span>    = note: <span style="color:#00f">to</span> `DataType::<span style="color:#2b91af">Char</span> <span style="">{</span> .. <span style="">}</span>`
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>note: trace_macro
</span></span><span style="display:flex;"><span>   --&gt; src/datatype/macros.rs:165:5
</span></span><span style="display:flex;"><span>    |
</span></span><span style="display:flex;"><span>165 |     <span style="color:#2b91af">decimal</span>! <span style="">{</span> datatype_scalar <span style="">}</span>;
</span></span><span style="display:flex;"><span>    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span></span><span style="display:flex;"><span>    |
</span></span><span style="display:flex;"><span>    = note: expanding `<span style="color:#2b91af">decimal</span>! <span style="">{</span> datatype_scalar <span style="">}</span>`
</span></span><span style="display:flex;"><span>    = note: <span style="color:#00f">to</span> `datatype_scalar!
</span></span><span style="display:flex;"><span>            <span style="">{</span> DataType :: <span style="color:#2b91af">Decimal</span> <span style="">{</span> .. <span style="">}</span>, DecimalArray, rust_decimal :: <span style="color:#2b91af">Decimal</span> <span style="">}</span>`
</span></span><span style="display:flex;"><span>    = note: expanding `datatype_scalar! <span style="">{</span> DataType :: <span style="color:#2b91af">Decimal</span> <span style="">{</span> .. <span style="">}</span>, DecimalArray, rust_decimal :: <span style="color:#2b91af">Decimal</span> <span style="">}</span>`
</span></span><span style="display:flex;"><span>    = note: <span style="color:#00f">to</span> `rust_decimal::<span style="color:#2b91af">Decimal</span>`
</span></span></code></pre></div><p>可以看到三句话分别展开成了 <code>BoolArray</code>, <code>DataType::Char { .. }</code>, <code>Decimal</code>, 正好可以用在 <code>build_expression</code> 里面。</p>
<h3 id="展开所有比较函数">展开所有比较函数</h3>
<p>接下来我们借助类型体操 Day 3, 4 里面的技巧，用 <code>for_all_cmp_combinations</code> 和 <code>impl_cmp_expression_of</code> 这一对 macro 来展开所有的比较函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#a31515">/// Composes all combinations of possible comparisons
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">///
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">/// Each item in the list `{ a, b, c }` represents:
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">/// * 1st position: left input type.
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">/// * 2nd position: right input type.
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">/// * 3rd position: cast type. For example, we need to cast the left i32 to i64 before comparing i32
</span></span></span><span style="display:flex;"><span><span style="color:#a31515">///   and i64.
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span>macro_rules! for_all_cmp_combinations {
</span></span><span style="display:flex;"><span>    (<span style="color:#00f">$macro</span>:<span style="color:#2b91af">tt</span> <span style="color:#00f">$(,</span> <span style="color:#00f">$x</span>:<span style="color:#2b91af">tt</span>)*) =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">$macro</span>! {
</span></span><span style="display:flex;"><span>            [<span style="color:#00f">$($x</span>),*],
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// comparison for the same type
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            { int16, int16, int16 },
</span></span><span style="display:flex;"><span>            { int32, int32, int32 },
</span></span><span style="display:flex;"><span>            { int64, int64, int64 },
</span></span><span style="display:flex;"><span>            { float32, float32, float32 },
</span></span><span style="display:flex;"><span>            { float64, float64, float64 },
</span></span><span style="display:flex;"><span>            { decimal, decimal, decimal },
</span></span><span style="display:flex;"><span>            { fwchar, fwchar, fwchar },
</span></span><span style="display:flex;"><span>            { varchar, varchar, varchar },
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// comparison across integer types
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            { int16, int32, int32 },
</span></span><span style="display:flex;"><span>            { int32, int16, int32 },
</span></span><span style="display:flex;"><span>            { int16, int64, int64 },
</span></span><span style="display:flex;"><span>            { int32, int64, int64 },
</span></span><span style="display:flex;"><span>            { int64, int16, int64 },
</span></span><span style="display:flex;"><span>            { int64, int32, int64 },
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// comparison across float types
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            { float32, float64, float64 },
</span></span><span style="display:flex;"><span>            { float64, float32, float64 },
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// comparison across integer and float32 types
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            { int16, float32, float32 },
</span></span><span style="display:flex;"><span>            { float32, int16, float32 },
</span></span><span style="display:flex;"><span>            { int32, float32, float64 },
</span></span><span style="display:flex;"><span>            { float32, int32, float64 },
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// comparison across integer and float64 types
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            { int32, float64, float64 },
</span></span><span style="display:flex;"><span>            { float64, int32, float64 },
</span></span><span style="display:flex;"><span>            { int16, float64, float64 },
</span></span><span style="display:flex;"><span>            { float64, int16, float64 },
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// comparison with decimal types
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            { int16, decimal, decimal },
</span></span><span style="display:flex;"><span>            { decimal, int16, decimal },
</span></span><span style="display:flex;"><span>            { int32, decimal, decimal },
</span></span><span style="display:flex;"><span>            { decimal, int32, decimal },
</span></span><span style="display:flex;"><span>            { int64, decimal, decimal },
</span></span><span style="display:flex;"><span>            { decimal, int64, decimal }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们使用 <code>for_all_cmp_combinations</code> 这个 macro 来声明所有可以比较的数据类型。以 <code>{ int16, float32, float32 }</code> 这一行为例，它的意思就是 int16 和 float32 可以进行比较，比较前 cast 到 float32 类型。</p>
<p>然后我们考虑一下 <code>impl_cmp_expression_of</code> 这个 macro 怎么实现。回到最开始写的一段代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>(DataType::BigInt, DataType::Integer) =&gt; Box::new(
</span></span><span style="display:flex;"><span>    BinaryExpression::&lt;<span style="color:#2b91af">i64</span>, <span style="color:#2b91af">i32</span>, <span style="color:#2b91af">bool</span>, _&gt;::new(cmp_le::&lt;<span style="color:#2b91af">i64</span>, <span style="color:#2b91af">i32</span>, <span style="color:#2b91af">i64</span>&gt;),
</span></span><span style="display:flex;"><span>),
</span></span></code></pre></div><p>一拍脑袋，所有用到类型的地方都可以用 macro 来改写。假设输入的两个类型分别是 <code>$i1</code> 和 <code>$i2</code>，需要 cast 成 <code>$convert</code> 类型。先看 match arm：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>(DataType::BigInt, DataType::Integer) =&gt;
</span></span><span style="display:flex;"><span><span style="color:#008000">// ... can be rewritten to
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>(<span style="color:#00f">$i1</span>! { datatype_match_pattern }, <span style="color:#00f">$i2</span>! { datatype_match_pattern }) =&gt;
</span></span></code></pre></div><p>然后看看 BinaryExpression 这一段：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>Box::new(
</span></span><span style="display:flex;"><span>    BinaryExpression::&lt;<span style="color:#2b91af">i64</span>, <span style="color:#2b91af">i32</span>, <span style="color:#2b91af">bool</span>, _&gt;::new(cmp_le::&lt;<span style="color:#2b91af">i64</span>, <span style="color:#2b91af">i32</span>, <span style="color:#2b91af">i64</span>&gt;),
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#008000">// ... can be rewritten to
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>Box::new(BinaryExpression::&lt;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">$i1</span>! { datatype_scalar },
</span></span><span style="display:flex;"><span>    <span style="color:#00f">$i2</span>! { datatype_scalar },
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">bool</span>,
</span></span><span style="display:flex;"><span>    _
</span></span><span style="display:flex;"><span>&gt;::new(
</span></span><span style="display:flex;"><span>    <span style="color:#00f">$cmp_func</span>::&lt;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">$i1</span>! { datatype_scalar },
</span></span><span style="display:flex;"><span>        <span style="color:#00f">$i2</span>! { datatype_scalar },
</span></span><span style="display:flex;"><span>        <span style="color:#00f">$convert</span>! { datatype_scalar }
</span></span><span style="display:flex;"><span>    &gt;,
</span></span><span style="display:flex;"><span>))
</span></span></code></pre></div><p>这样就得到了 <code>impl_cmp_expression_of</code> 的实现：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>macro_rules! impl_cmp_expression_of {
</span></span><span style="display:flex;"><span>    ([<span style="color:#00f">$i1t</span>:<span style="color:#2b91af">ident</span>, <span style="color:#00f">$i2t</span>:<span style="color:#2b91af">ident</span>, <span style="color:#00f">$cmp_func</span>:<span style="color:#2b91af">tt</span>], <span style="color:#00f">$(</span>{ <span style="color:#00f">$i1</span>:<span style="color:#2b91af">tt</span>, <span style="color:#00f">$i2</span>:<span style="color:#2b91af">tt</span>, <span style="color:#00f">$convert</span>:<span style="color:#2b91af">tt</span> }),*) =&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">match</span> (<span style="color:#00f">$i1t</span>, <span style="color:#00f">$i2t</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">$(</span>
</span></span><span style="display:flex;"><span>                (<span style="color:#00f">$i1</span>! { datatype_match_pattern }, <span style="color:#00f">$i2</span>! { datatype_match_pattern }) =&gt; {
</span></span><span style="display:flex;"><span>                    Box::new(BinaryExpression::&lt;
</span></span><span style="display:flex;"><span>                        <span style="color:#00f">$i1</span>! { datatype_scalar },
</span></span><span style="display:flex;"><span>                        <span style="color:#00f">$i2</span>! { datatype_scalar },
</span></span><span style="display:flex;"><span>                        <span style="color:#2b91af">bool</span>,
</span></span><span style="display:flex;"><span>                        _
</span></span><span style="display:flex;"><span>                    &gt;::new(
</span></span><span style="display:flex;"><span>                        <span style="color:#00f">$cmp_func</span>::&lt;
</span></span><span style="display:flex;"><span>                            <span style="color:#00f">$i1</span>! { datatype_scalar },
</span></span><span style="display:flex;"><span>                            <span style="color:#00f">$i2</span>! { datatype_scalar },
</span></span><span style="display:flex;"><span>                            <span style="color:#00f">$convert</span>! { datatype_scalar }
</span></span><span style="display:flex;"><span>                        &gt;,
</span></span><span style="display:flex;"><span>                    ))
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            )*
</span></span><span style="display:flex;"><span>            (other_dt1, other_dt2) =&gt; unimplemented!(<span style="color:#a31515">&#34;unsupported comparison: </span><span style="color:#a31515">{:?}</span><span style="color:#a31515"> &lt;</span><span style="color:#a31515">{}</span><span style="color:#a31515">&gt; </span><span style="color:#a31515">{:?}</span><span style="color:#a31515">&#34;</span>,
</span></span><span style="display:flex;"><span>                other_dt1,
</span></span><span style="display:flex;"><span>                stringify!(<span style="color:#00f">$cmp_func</span>),
</span></span><span style="display:flex;"><span>                other_dt2)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>最后，在 <code>build_expression</code> 里面用宏展开：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#a31515">/// Build expression with runtime information.
</span></span></span><span style="display:flex;"><span><span style="color:#a31515"></span><span style="color:#00f">pub</span> <span style="color:#00f">fn</span> build_binary_expression(
</span></span><span style="display:flex;"><span>    f: <span style="color:#2b91af">ExpressionFunc</span>,
</span></span><span style="display:flex;"><span>    i1: <span style="color:#2b91af">DataType</span>,
</span></span><span style="display:flex;"><span>    i2: <span style="color:#2b91af">DataType</span>,
</span></span><span style="display:flex;"><span>) -&gt; Box&lt;<span style="color:#00f">dyn</span> Expression&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">use</span> ExpressionFunc::*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">use</span> <span style="color:#00f">crate</span>::expr::cmp::*;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">use</span> <span style="color:#00f">crate</span>::expr::string::*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">match</span> f {
</span></span><span style="display:flex;"><span>        CmpLe =&gt; for_all_cmp_combinations! { impl_cmp_expression_of, i1, i2, cmp_le },
</span></span><span style="display:flex;"><span>        CmpGe =&gt; for_all_cmp_combinations! { impl_cmp_expression_of, i1, i2, cmp_ge },
</span></span><span style="display:flex;"><span>        CmpEq =&gt; for_all_cmp_combinations! { impl_cmp_expression_of, i1, i2, cmp_eq },
</span></span><span style="display:flex;"><span>        CmpNe =&gt; for_all_cmp_combinations! { impl_cmp_expression_of, i1, i2, cmp_ne },
</span></span><span style="display:flex;"><span>        StrContains =&gt; Box::new(BinaryExpression::&lt;String, String, <span style="color:#2b91af">bool</span>, _&gt;::new(
</span></span><span style="display:flex;"><span>            str_contains,
</span></span><span style="display:flex;"><span>        )),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>由此，我们用简单的代码，实现了任何两种类型比较函数的向量化。Day 7 结束了！</p>
<hr>
<p>欢迎在这篇文章对应的 <a href="https://github.com/skyzh/skyzh.github.io/issues/9">Issue</a> 下使用 GitHub 账号评论、交流你的想法。</p>
<p><em>（未完待续）</em></p>

				
			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/rust">Rust</a></li>
							
							<li><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li>
							
							<li><a href="/tags/%E6%89%A7%E8%A1%8C%E5%99%A8">执行器</a></li>
							
							<li><a href="/tags/%E7%B1%BB%E5%9E%8B">类型</a></li>
							
							<li><a href="/tags/gat">GAT</a></li>
							
						</ul>
					
				
			</div></div>
	</div>
	

<div class="footer wrapper">
	<nav class="nav">
		<div>2023  © Alkdis Chen |  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a>  
    
    <div class="wrap">
    

        
    </div>

    
    
    
    
    </div>
	</nav>
</div>







  

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-52525161-8', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script>feather.replace()</script>
</body>
</html>
